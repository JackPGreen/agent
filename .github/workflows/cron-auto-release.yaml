name: Tag a new release
on:
  schedule:
    # 25.10 releases
    - cron: "0 10 * * 1"
    # Latest releases
    - cron: "0 10 * * 2"
  workflow_dispatch:
    inputs:
      branch:
        description: The branch we want to trigger a tag for.
        required: false
        default: "main"
        type: string
jobs:
  find-last-good:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
    outputs:
      sha: ${{ steps.get-commit.outputs.sha }}
      branch: ${{ steps.detect-branch.outputs.branch || 'main' }}
    steps:
      - uses: actions/checkout@v5
        with:
          # check out the entire repo history for SHA verification
          fetch-depth: 0

      - name: 25.10 run
        if: github.event_name == 'schedule' && github.event.schedule=='0 10 * * 1'
        run: |
          echo "BRANCH=release/25.10-lts" >> $GITHUB_ENV
        shell: bash

      - name: main run
        if: github.event_name == 'schedule' && github.event.schedule=='0 10 * * 2'
        run: |
          echo "BRANCH=main" >> $GITHUB_ENV
        shell: bash

      - name: Manual run
        if: github.event_name == 'workflow_dispatch'
        run: |
          echo "BRANCH=${{ github.event.inputs.branch }}" >> $GITHUB_ENV
        shell: bash

      - name: Figure out branch we are running for
        id: detect-branch
        run: |
          echo "branch=$BRANCH"
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
        shell: bash

      - name: Find matching workflow
        uses: SamhammerAG/last-successful-build-action@v7
        id: get-commit
        with:
          token: "${{ secrets.GITHUB_TOKEN }}"
          branch: ${{ steps.detect-branch.outputs.branch || 'main' }}
          workflow: "Build and test"
          verify: true

  create-tag:
    name: Create tag for ${{ needs.find-last-good.outputs.branch }}
    runs-on: ubuntu-latest
    needs:
      - find-last-good
    permissions:
      contents: write
      id-token: write
    outputs:
      tag_name: ${{ steps.tag_name.outputs.tag_name }}
    steps:
      - name: Authenticate with GCP
        uses: google-github-actions/auth@v3
        with:
          workload_identity_provider: "projects/841522437311/locations/global/workloadIdentityPools/github-actions/providers/github-actions"
          service_account: "terraform-infra@infrastructure-464010.iam.gserviceaccount.com"

      - id: get-secrets
        name: Get secrets from GCP Secret Manager
        # This step retrieves secrets from GCP Secret Manager and sets them as outputs
        # The secrets can then be accessed in subsequent steps using ${{ steps.get-secrets.outputs.<secret_name> }}
        uses: "google-github-actions/get-secretmanager-secrets@v3"
        with:
          secrets: |-
            github-pat:projects/626836145334/secrets/GITHUB_CI_PAT

      - uses: actions/checkout@v5
        with:
          ref: ${{ needs.find-last-good.outputs.sha }}
          # The tag must be pushed using a PAT to ensure workflows then run.
          token: ${{ steps.get-secrets.outputs.github-pat }}
          # We need tags present to check for them
          fetch-tags: true

      - name: Tag name
        id: tag_name
        run: |
          if [[ "$BRANCH" != 'main' ]]; then
            echo "Creating next tag name in sequence"
            # Get last tag for branch
            LAST_TAG=$(git describe --tags --match="v*" "$BRANCH" --abbrev=0)
            echo "Found last tag=$LAST_TAG"
            VNUM1=$(echo "$LAST_TAG" | cut -d"." -f1)
            VNUM2=$(echo "$LAST_TAG" | cut -d"." -f2)
            VNUM3=$(echo "$LAST_TAG" | cut -d"." -f3)
            VNUM3=$((VNUM3+1))
            NEW_TAG="$VNUM1.$VNUM2.$VNUM3"
            echo "tag_name=$NEW_TAG"
            echo "tag_name=$NEW_TAG" >> $GITHUB_OUTPUT
          else
            echo "Create a tag name based on the current date"
            # Format: vYY.M.W
            YEAR=$(date +%y)
            MONTH=$(date +%-m)
            WEEK=$((($(date +%-d)-1)/7+1))
            echo "tag_name=v${YEAR}.${MONTH}.${WEEK}"
            echo "tag_name=v${YEAR}.${MONTH}.${WEEK}" >> $GITHUB_OUTPUT
          fi
        shell: bash
        env:
          BRANCH: ${{ needs.find-last-good.outputs.branch }}

      - name: Check if tag already exists
        run: |
          # Check if the tag already exists on the remote
          if git ls-remote --exit-code --tags origin "$TAG_NAME" >/dev/null; then
            echo "Tag $TAG_NAME already exists. Exiting."
            git ls-remote --tags
            exit 1
          fi
        shell: bash
        env:
          TAG_NAME: ${{ steps.tag_name.outputs.tag_name }}

      # The tag must be pushed using a PAT to ensure workflows then run.
      - name: Create tag
        run: |
          git tag ${{ steps.tag_name.outputs.tag_name }}
          git push origin ${{ steps.tag_name.outputs.tag_name }}
        shell: bash
